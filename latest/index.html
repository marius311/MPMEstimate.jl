<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MuseInference.jl · MuseInference</title><meta name="title" content="MuseInference.jl · MuseInference"/><meta property="og:title" content="MuseInference.jl · MuseInference"/><meta property="twitter:title" content="MuseInference.jl · MuseInference"/><meta name="description" content="Documentation for MuseInference."/><meta property="og:description" content="Documentation for MuseInference."/><meta property="twitter:description" content="Documentation for MuseInference."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/muse.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MuseInference</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>MuseInference.jl</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Install"><span>Install</span></a></li><li class="toplevel"><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="userapi/">User API</a></li><li><a class="tocitem" href="devapi/">Developer API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MuseInference.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MuseInference.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/marius311/MuseInference.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MuseInference.jl"><a class="docs-heading-anchor" href="#MuseInference.jl">MuseInference.jl</a><a id="MuseInference.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MuseInference.jl" title="Permalink"></a></h1><p><a href="https://cosmicmar.com/MuseInference.jl/latest"><img src="https://img.shields.io/badge/documentation-latest-blue.svg" alt/></a> <a href="https://github.com/marius311/MuseInference.jl"><img src="https://img.shields.io/badge/source-github-blue" alt/></a></p><p><a href="https://github.com/marius311/MuseInference.jl/actions/workflows/docs.yml"><img src="https://github.com/marius311/MuseInference.jl/actions/workflows/docs.yml/badge.svg" alt/></a></p><p>The Marginal Unbiased Score Expansion (MUSE) method is a generic tool for hierarchical Bayesian inference. MUSE performs approximate marginalization over arbitrary non-Gaussian and high-dimensional latent spaces, providing Gaussianized constraints on hyper parameters of interest. It is much faster than exact methods like Hamiltonian Monte Carlo (HMC), and requires no user input like many Variational Inference (VI), and Likelihood-Free Inference (LFI) or Simulation-Based Inference (SBI) methods. It excels in high-dimensions, which challenge these other methods. It is approximate, so its results may need to be spot-checked against exact methods, but it is itself exact in asymptotic limit of a large number of data modes contributing to each hyperparameter, or in the limit of Gaussian joint likelihood regardless the number of data modes. For more details, see <a href="https://arxiv.org/abs/2112.09354">Millea &amp; Seljak, 2021</a>.</p><p>MUSE works on standard hierarchical problems, where the likelihood is of the form:</p><p class="math-container">\[\mathcal{P}(x\,|\,\theta) = \int {\rm d}z \, \mathcal{P}(x,z\,|\,\theta)\]</p><p>In our notation, <span>$x$</span> are the observed variables (the &quot;data&quot;), <span>$z$</span> are unobserved &quot;latent&quot; variables, and <span>$\theta$</span> are some &quot;hyperparameters&quot; of interest. MUSE is applicable when the goal of the analysis is to estimate the hyperparameters, <span>$\theta$</span>, but otherwise, the latent variables, <span>$z$</span>, do not need to be inferred (only marginalized out via the integral above). </p><p>The only requirements to run MUSE on a particular problem are that forward simulations from <span>$\mathcal{P}(x,z\,|\,\theta)$</span> can be generated, and gradients of the joint likelihood, <span>$\mathcal{P}(x,z\,|\,\theta)$</span> with respect to <span>$z$</span> and <span>$\theta$</span> can be computed. The marginal likelihood is never required, so MUSE could be considered a form of LFI/SBI. </p><h1 id="Install"><a class="docs-heading-anchor" href="#Install">Install</a><a id="Install-1"></a><a class="docs-heading-anchor-permalink" href="#Install" title="Permalink"></a></h1><p>MuseInference.jl is a Julia package for computing the MUSE estimate. To install it, run the following from the Julia package prompt:</p><pre><code class="nohighlight hljs">pkg&gt; add https://github.com/marius311/MuseInference.jl</code></pre><h1 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h1><p>The easiest way to use MuseInference is with problems defined via the Probabilistic Programming Language, <a href="https://turing.ml/stable/">Turing.jl</a>.</p><p>First, load up the packages we&#39;ll need:</p><pre><code class="language-julia hljs">using MuseInference, Turing
using AbstractDifferentiation, Dates, LinearAlgebra, Printf, Plots, Random, Zygote
Turing.setadbackend(:zygote)</code></pre><p>As an example, consider the following hierarchical problem, which has the classic <a href="https://mc-stan.org/docs/2_18/stan-users-guide/reparameterization-section.html">Neal&#39;s Funnel</a> problem embedded in it. Neal&#39;s funnel is a standard example of a non-Gaussian latent space which HMC struggles to sample efficiently without extra tricks. Specifically, we consider the model defined by:</p><p class="math-container">\[\begin{aligned}
\theta &amp;\sim {\rm Normal(0,3)} \\ 
z_i &amp;\sim {\rm Normal}(0,\exp(\theta/2)) \\ 
x_i &amp;\sim {\rm Normal}(z_i, 1)
\end{aligned}\]</p><p>for <span>$i=1...2048$</span>. This problem can be described by the following Turing model:</p><pre><code class="language-julia hljs">@model function funnel()
    θ ~ Normal(0, 3)
    z ~ MvNormal(zeros(2048), exp(θ)*I)
    x ~ MvNormal(z, I)
end</code></pre><p>Next, let&#39;s choose a true value of <span>$\theta=0$</span> and generate some simulated data which we&#39;ll use as &quot;observations&quot;:</p><pre><code class="language-julia hljs">Random.seed!(1)
(;x) = rand(funnel() | (θ=0,))
model = funnel() | (;x)</code></pre><p>We can run HMC on the problem to compute the &quot;true&quot; answer to compare against:</p><pre><code class="language-julia hljs">Random.seed!(2)
chain = @time sample(model, NUTS(100, 0.65, init_ϵ=0.5), 500)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"> 35.886290 seconds (109.69 M allocations: 32.190 GiB, 11.52% gc time)</code></pre><p>We next compute the MUSE estimate for the same problem. To reach the same Monte Carlo error as HMC, the number of MUSE simulations should be the same as the effective sample size of the chain we just ran. This is:</p><pre><code class="language-julia hljs">nsims = round(Int, ess(chain)[:θ,:ess])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">177</code></pre><p>Running the MUSE estimate, </p><pre><code class="language-julia hljs">Random.seed!(3)
muse_result = @time muse(model, 0; nsims, get_covariance=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  2.337250 seconds (6.29 M allocations: 1.723 GiB, 9.30% gc time)</code></pre><p>Now let&#39;s plot the different estimates. In this case, MUSE gives a nearly perfect answer in a fraction of the time.</p><pre><code class="language-julia hljs">histogram(collect(chain[&quot;θ&quot;][:]), normalize=:pdf, bins=10, label=@sprintf(&quot;HMC (%.1f seconds)&quot;, chain.info.stop_time - chain.info.start_time))
θs = range(-0.5,0.5,length=1000)
plot!(θs, pdf.(muse_result.dist, θs), label=@sprintf(&quot;MUSE (%.1f seconds)&quot;, (muse_result.time / Millisecond(1000))), lw=2)
vline!([0], c=:black, ls=:dash, alpha=0.5, label=nothing)
plot!(xlabel=&quot;θ&quot;, ylabel=&quot;P(θ|x)&quot;, title=&quot;2048-dimensional noisy funnel&quot;)</code></pre><img src="index-be148607.svg" alt="Example block output"/><p>The timing<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> difference is indicative of the speedups over HMC that are possible. These get even more dramatic as we increase dimensionality, which is why MUSE really excels on high-dimensional problems.</p><hr/><p>It is also possible to use MuseInference without Turing. The MUSE estimate requires three things:</p><ol><li><p>A function which samples from the joint likelihood, <span>$\mathcal{P}(x,z\,|\,\theta)$</span>, with signature:</p><pre><code class="language-julia hljs">function sample_x_z(rng::AbstractRNG, θ)
    # ...
    return (;x, z)
end</code></pre><p>where <code>rng</code> is an <code>AbstractRNG</code> object which should be used when generating random numbers, <code>θ</code> are the parameters, and return value should be a named tuple <code>(;x, z)</code>. </p></li><li><p>A function which computes the joint likelihood, <span>$\mathcal{P}(x,z\,|\,\theta)$</span>, with signature:</p><pre><code class="language-julia hljs">function logLike(x, z, θ) 
    # return log likelihood
end</code></pre><p>A user-specifiable automatic differentiation library will be used to take gradients of this function. </p></li><li><p>A function which computes the prior, <span>$\mathcal{P}(\theta)$</span>, with signature:</p><pre><code class="language-julia hljs">function logPrior(θ)
    # return log prior
end</code></pre><p>If none is provided, the prior is assumed uniform. </p></li></ol><p>In all cases, <code>x</code>, <code>z</code>, and <code>θ</code>, can be of any type which supports basic arithmetic, including scalars, <code>Vector</code>s, special vector types like <code>ComponentArray</code>s, etc...</p><p>We can compute the MUSE estimate for the same funnel problem as above. To do so, first we create a <code>SimpleMuseProblem</code> object which specifies the three functions:</p><pre><code class="language-julia hljs">prob = SimpleMuseProblem(
    x,
    function sample_x_z(rng, θ)
        z = rand(rng, MvNormal(zeros(2048), exp(θ)*I))
        x = rand(rng, MvNormal(z, I))
        (;x, z)
    end,
    function logLike(x, z, θ)
        -(1//2) * (sum((x .- z).^2) + sum(z.^2) / exp(θ) + 2048*θ)
    end,
    function logPrior(θ)
        -θ^2/(2*3^2)
    end;
    autodiff = AbstractDifferentiation.ZygoteBackend()
)</code></pre><p>And compute the estimate:</p><pre><code class="language-julia hljs">Random.seed!(3)
muse_result_manual = muse(prob, 0; nsims, get_covariance=true)</code></pre><p>This gives the same answer as before:</p><pre><code class="language-julia hljs">(muse_result.θ[1], muse_result_manual.θ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.13866195962918862, 0.138661959629189)</code></pre><hr/><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Julia experts may wonder if the <code>@time</code> calls above aren&#39;t just mainly timing compilation, but this document is generated with hidden &quot;warmup&quot; calls which ensure that only the runtime is measured.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="userapi/">User API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 23 April 2024 21:49">Tuesday 23 April 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
