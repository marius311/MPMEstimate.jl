<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer API · MuseInference</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/muse.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MuseInference</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">MuseInference.jl</a></li><li><a class="tocitem" href="../userapi/">User API</a></li><li class="is-active"><a class="tocitem" href>Developer API</a><ul class="internal"><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developer API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developer API</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer-API"><a class="docs-heading-anchor" href="#Developer-API">Developer API</a><a id="Developer-API-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-API" title="Permalink"></a></h1><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This page describes how to create a custom <code>AbstractMuseProblem</code> type. You might want to do this if you are creating a new interface between MuseInference and some PPL package that is not currently supported, or if you have a problem which <a href="../userapi/#MuseInference.SimpleMuseProblem"><code>SimpleMuseProblem</code></a> cannot handle. You <em>do not</em> need to do this if you have a model you can describe with a supported PPL package (Turing or Soss), or if <a href="../userapi/#MuseInference.SimpleMuseProblem"><code>SimpleMuseProblem</code></a> is sufficient for you. </p><p>As a reminder, MUSE works on joint posteriors of the form,</p><p class="math-container">\[\mathcal{P}(x,z\,|\,\theta) \mathcal{P}(\theta)\]</p><p>where <span>$x$</span> represents one or more observed variables, <span>$z$</span> represents one or more latent variables, and <span>$\theta$</span> represents one of more hyper parameters which will be estimated by MUSE. The interface below more or less involves mapping these variables from your original problem to the form expected by MuseInference. The minimum functions you need to implement to get MUSE working are:</p><ul><li><p><a href="#MuseInference.sample_x_z"><code>MuseInference.sample_x_z</code></a> to sample from <span>$(x,z) \sim \mathcal{P}(x,z\,|\,\theta)$</span></p></li><li><p><a href="#MuseInference.∇θ_logLike"><code>MuseInference.∇θ_logLike</code></a> to compute the gradient,<span>$\nabla_\theta \log\mathcal{P}(x,z\,|\,\theta)$</span>.</p></li><li><p><a href="#MuseInference.logLike_and_∇z_logLike"><code>MuseInference.logLike_and_∇z_logLike</code></a> to compute <span>$(\log\mathcal{P}(x,z\,|\,\theta), \nabla_z \log\mathcal{P}(x,z\,|\,\theta))$</span>.</p></li><li><p><a href="#MuseInference.logPriorθ"><code>MuseInference.logPriorθ</code></a> (<em>optional</em>) to compute the prior, <span>$\log\mathcal{P}(\theta)$</span> (defaults to zero).</p></li></ul><p>The <span>$(x,z,\theta)$</span> can be any types which support basic arithmetic. </p><p>Internally in the function <a href="#MuseInference.ẑ_at_θ"><code>MuseInference.ẑ_at_θ</code></a>, MuseInference does a maximization over <span>$z$</span> using <code>logLike_and_∇z_logLike</code> and <code>Optim.jl</code>&#39;s <code>LBFGS</code> solver. If you&#39;d like, you can customize the entire maximization by directly implementing <code>ẑ_at_θ</code> yourself, in which case you do not need to implement <code>logLike_and_∇z_logLike</code> at all. </p><p>MuseInference assumes <span>$z$</span> and <span>$\theta$</span> have support on <span>$(-\infty,\infty)$</span>. For some problems, this may not be the case, e.g. if you have a <span>$\theta \sim {\rm LogNormal}$</span>, then <span>$\theta$</span> only has support on <span>$(0,\infty)$</span>. If this is the case for your problem, you have three options:</p><ul><li><p>If none of the internal solvers &quot;bump up&quot; against the edges of the support, then you don&#39;t need to do anything else.</p></li><li><p>Outside of MuseInference, you can perform a change-of-variables for <span>$\theta$</span> and/or <span>$z$</span> such that the transformed variables have support on <span>$(-\infty,\infty)$</span>, and implement the functions above in terms of the transformed variables. In this case, MuseInference never knows (or needs to know) about the transformation, and the returned estimate of <span>$\theta$</span> will be an estimate of the transformed <span>$\theta$</span> (which if desired you can transform back outside of MuseInference).</p></li><li><p>If you would like MuseInference itself to return an estimate of the <em>untransformed</em> <span>$\theta$</span>, then you can implement:</p><ul><li><a href="#MuseInference.transform_θ"><code>MuseInference.transform_θ</code></a></li><li><a href="#MuseInference.inv_transform_θ"><code>MuseInference.inv_transform_θ</code></a></li><li>The extended forms of <a href="#MuseInference.∇θ_logLike"><code>MuseInference.∇θ_logLike</code></a> and <a href="#MuseInference.logPriorθ"><code>MuseInference.logPriorθ</code></a> which take a <code>θ_space</code> argument.</li></ul></li></ul><p>MuseInference doesn&#39;t provide an estimate of <span>$z$</span>, so if necessary, you should handle transforming it to <span>$(-\infty,\infty)$</span> outside of MuseInference.</p><p>Once your define the custom <code>AbstractMuseProblem</code>, you can use <a href="#MuseInference.check_self_consistency"><code>MuseInference.check_self_consistency</code></a> to run some self-consistency checks on it.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MuseInference.check_self_consistency"><code>MuseInference.check_self_consistency</code></a></li><li><a href="#MuseInference.inv_transform_θ"><code>MuseInference.inv_transform_θ</code></a></li><li><a href="#MuseInference.logLike_and_∇z_logLike"><code>MuseInference.logLike_and_∇z_logLike</code></a></li><li><a href="#MuseInference.logPriorθ"><code>MuseInference.logPriorθ</code></a></li><li><a href="#MuseInference.sample_x_z"><code>MuseInference.sample_x_z</code></a></li><li><a href="#MuseInference.standardizeθ"><code>MuseInference.standardizeθ</code></a></li><li><a href="#MuseInference.transform_θ"><code>MuseInference.transform_θ</code></a></li><li><a href="#MuseInference.ẑ_at_θ"><code>MuseInference.ẑ_at_θ</code></a></li><li><a href="#MuseInference.∇θ_logLike"><code>MuseInference.∇θ_logLike</code></a></li></ul><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MuseInference.transform_θ" href="#MuseInference.transform_θ"><code>MuseInference.transform_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_θ(prob::AbstractMuseProblem, θ)</code></pre><p>Map <code>θ</code> to a space where its domain is <span>$(-\infty,\infty)$</span>. Defaults to identity function. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MuseInference.inv_transform_θ" href="#MuseInference.inv_transform_θ"><code>MuseInference.inv_transform_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inv_transform_θ(prob::AbstractMuseProblem, θ)</code></pre><p>Map <code>θ</code> from the space where its domain is <span>$(-\infty,\infty)$</span> back to the original space. Defaults to identity function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MuseInference.sample_x_z" href="#MuseInference.sample_x_z"><code>MuseInference.sample_x_z</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a tuple <code>(x,z)</code> with data <code>x</code> and latent space <code>z</code> which are a sample from the joint likelihood, given <code>θ</code>. The signature of the function should be:</p><pre><code class="nohighlight hljs">sample_x_z(prob::AbstractMuseProblem, rng::AbstractRNG, θ)</code></pre><p>Random numbers generated internally should use <code>rng</code>.</p><p>The <code>θ</code> argument to this function will always be in the un-transfored <code>θ</code> space.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MuseInference.∇θ_logLike" href="#MuseInference.∇θ_logLike"><code>MuseInference.∇θ_logLike</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the gradient of the joint log likelihood with respect to hyper parameters <code>θ</code>, evaluated at data <code>x</code> and latent space <code>z</code>. The signature of the function should be:</p><pre><code class="nohighlight hljs">∇θ_logLike(prob::AbstractMuseProblem, x, z, θ)</code></pre><p>If the problem needs a transformation of <code>θ</code> to map its domain to <span>$(-\infty,\infty)$</span>, then it should instead implement:</p><pre><code class="nohighlight hljs">∇θ_logLike(prob::AbstractMuseProblem, x, z, θ, θ_space)</code></pre><p>where <code>θ_space</code> will be either <code>Transformedθ()</code> or <code>UnTransformedθ()</code>. In this case, the <code>θ</code> argument will be passed in the space given by <code>θ_space</code> and the gradient should be w.r.t. to <code>θ</code> in that space.</p><p><code>z</code> must have domain <span>$(-\infty,\infty)$</span>. If a transformation is required to make this the case, that should be handled internal to this function and <code>z</code> will always refer to the transformed <code>z</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MuseInference.logLike_and_∇z_logLike" href="#MuseInference.logLike_and_∇z_logLike"><code>MuseInference.logLike_and_∇z_logLike</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return a tuple <code>(logLike, ∇z_logLike)</code> which give the log likelihood and its gradient with respect to the latent space <code>z</code>, evaluated at hyper parameters <code>θ</code> and data <code>x</code> . The signature of the function should be:</p><pre><code class="nohighlight hljs">logLike_and_∇z_logLike(prob::AbstractMuseProblem, x, z, θ)</code></pre><p><code>z</code> must have domain <span>$(-\infty,\infty)$</span>. If a transformation is required to make this the case, that should be handled internal to this function and <code>z</code> will always refer to the transformed <code>z</code>.</p><p>The <code>θ</code> argument to this function will always be in the un-transfored <code>θ</code> space.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Alternatively, custom problems can implement <code>ẑ_at_θ</code> directly and forego this method. The default <code>ẑ_at_θ</code> runs LBFGS with Optim.jl using <code>logLike_and_∇z_logLike</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MuseInference.logPriorθ" href="#MuseInference.logPriorθ"><code>MuseInference.logPriorθ</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the log-prior at <code>θ</code>. The signature of the function should be:</p><pre><code class="nohighlight hljs">logPriorθ(prob::AbstractMuseProblem, θ)</code></pre><p>If the problem needs a transformation of <code>θ</code> to map its domain to <span>$(-\infty,\infty)$</span>, then it should instead implement:</p><pre><code class="nohighlight hljs">logPriorθ(prob::AbstractMuseProblem, θ, θ_space)</code></pre><p>where <code>θ_space</code> will be either <code>Transformedθ()</code> or <code>UnTransformedθ()</code>. In this case, the <code>θ</code> argument will be passed in the space given by <code>θ_space</code>. </p><p>Defaults to zero log-prior.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MuseInference.ẑ_at_θ" href="#MuseInference.ẑ_at_θ"><code>MuseInference.ẑ_at_θ</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the best-fit latent space <code>z</code> given data <code>x</code> and parameters <code>θ</code>. The signature of the function should be: </p><pre><code class="nohighlight hljs">ẑ_at_θ(prob::AbstractMuseProblem, x, z₀, θ; ∇z_logLike_atol)</code></pre><p>The return value should be <code>(ẑ, info)</code> where <code>info</code> can be any extra diagonstic info which will be saved in the MUSE result. </p><p>The <code>θ</code> argument to this function will always be in the un-transfored <code>θ</code> space.</p><p>The <code>z₀</code> should be used as a starting guess for the solution. </p><p><code>z</code> must have domain <span>$(-\infty,\infty)$</span>. If a transformation is required to make this the case, that should be handled internal to this function, and the return value should refer to the transformed <code>z</code>. </p><p>The default implementation of this method uses <a href="#MuseInference.logLike_and_∇z_logLike"><code>logLike_and_∇z_logLike</code></a> and Optim.jl&#39;s LBFGS to iteratively maximize the log likelihood. Custom problems are free to override this default if desired, in which case <a href="#MuseInference.logLike_and_∇z_logLike"><code>logLike_and_∇z_logLike</code></a> does not need to be implemented.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MuseInference.standardizeθ" href="#MuseInference.standardizeθ"><code>MuseInference.standardizeθ</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Pre-process a user-provided <code>θ</code> into the data-structure used internally in the computation. E.g. this allow the user to pass a <code>NamedTuple</code> to functions like <code>muse</code> or <code>get_J!</code> while internally converting it to a <code>ComponentVector</code>. The signature of the function should be:</p><pre><code class="nohighlight hljs">standardizeθ(prob::AbstractMuseProblem, θ)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="MuseInference.check_self_consistency" href="#MuseInference.check_self_consistency"><code>MuseInference.check_self_consistency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_self_consistency(
    prob, 
    θ;
    fdm = central_fdm(3, 1),
    atol = 1e-3,
    rng = Random.default_rng(),
    has_volume_factor = true
)</code></pre><p>Checks the self-consistency of a defined problem at a given <code>θ</code>, e.g. check that <code>inv_transform_θ(prob, transform_θ(prob, θ)) ≈ θ</code>, etc... This is mostly useful as a diagonostic when implementing a new <code>AbstractMuseProblem</code>. </p><p>A random <code>x</code> and <code>z</code> are sampled from <code>rng</code>. Finite differences are computed using <code>fdm</code> and <code>atol</code> set the tolerance for <code>≈</code>. <code>has_volume_factor</code> determines if the transformation includes the logdet jacobian in the likelihood.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../userapi/">« User API</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 5 March 2023 00:19">Sunday 5 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
